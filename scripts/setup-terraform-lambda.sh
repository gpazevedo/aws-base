#!/bin/bash
# =============================================================================
# Generate Lambda Service Terraform Configuration
# =============================================================================
# This script creates Terraform files for deploying Lambda functions
# in the terraform/ directory with environment-specific configurations
#
# Usage: ./scripts/setup-terraform-lambda.sh [SERVICE_NAME] [ENABLE_API_KEY]
#
# Examples:
#   ./scripts/setup-terraform-lambda.sh api false          # Create lambda-api.tf
#   ./scripts/setup-terraform-lambda.sh worker true        # Create lambda-worker.tf
#   ./scripts/setup-terraform-lambda.sh                    # Create lambda-api.tf (default)
# =============================================================================

set -e

# Parse command line arguments
SERVICE_NAME="${1:-api}"        # Default: 'api' for backward compatibility
ENABLE_API_KEY="${2:-true}"     # Default: enabled

TERRAFORM_DIR="terraform"
BOOTSTRAP_DIR="bootstrap"
ENVIRONMENTS=("dev" "test" "prod")

echo "üöÄ Setting up Lambda service Terraform configuration..."
echo ""

# =============================================================================
# Validate Service Directory
# =============================================================================

# Check if service directory exists in backend/
if [ ! -d "backend/${SERVICE_NAME}" ]; then
  echo "‚ùå Error: Service directory not found: backend/${SERVICE_NAME}"
  echo ""
  echo "Available services in backend/:"
  ls -d backend/*/ 2>/dev/null | xargs -n1 basename | grep -v "^$" || echo "  None found"
  echo ""
  echo "To create a new service, first create the directory:"
  echo "  mkdir -p backend/${SERVICE_NAME}"
  echo "  cp -r backend/api/* backend/${SERVICE_NAME}/"
  echo "  # Then customize backend/${SERVICE_NAME}/main.py for your service"
  exit 1
fi

echo "‚úÖ Service directory found: backend/${SERVICE_NAME}"
echo ""

# =============================================================================
# Check Bootstrap Configuration
# =============================================================================

# Check if bootstrap has been initialized
if [ ! -f "$BOOTSTRAP_DIR/terraform.tfvars" ]; then
  echo "‚ö†Ô∏è  Warning: Bootstrap terraform.tfvars not found"
  echo "   Using default values for examples"
  echo "   You should run bootstrap first: cp bootstrap/terraform.tfvars.example bootstrap/terraform.tfvars"
  echo ""
  PROJECT_NAME="<YOUR-PROJECT>"
  AWS_REGION="us-east-1"
else
  # Read configuration from bootstrap
  PROJECT_NAME=$(grep '^project_name' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  AWS_REGION=$(grep '^aws_region' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_ORG=$(grep '^github_org' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_REPO=$(grep '^github_repo' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
fi

# Set defaults if not found
: ${GITHUB_ORG:="<YOUR-ORG>"}
: ${GITHUB_REPO:="<YOUR-REPO>"}

echo "üìã Configuration:"
echo "   Service: $SERVICE_NAME"
echo "   Project: $PROJECT_NAME"
echo "   Region: $AWS_REGION"
echo "   GitHub: $GITHUB_ORG/$GITHUB_REPO"
echo "   API Key: $ENABLE_API_KEY"
echo ""
echo "=================================================="
echo "üîë API Key Authentication Configuration"
echo "=================================================="
if [ "$ENABLE_API_KEY" = "true" ]; then
  echo "‚úÖ API Key authentication will be ENABLED"
  echo ""
  echo "Your API will require an API key for all requests."
  echo "After deployment, retrieve your API key with:"
  echo "  cd terraform && terraform output -raw api_key_value"
  echo ""
  echo "To disable API Key authentication, edit terraform/environments/{env}.tfvars:"
  echo "  enable_api_key = false"
else
  echo "‚ö†Ô∏è  API Key authentication will be DISABLED"
  echo ""
  echo "Your API will be publicly accessible without authentication."
  echo "This is NOT recommended for production environments."
  echo ""
  echo "To enable API Key authentication, edit terraform/environments/{env}.tfvars:"
  echo "  enable_api_key = true"
fi
echo "=================================================="
echo ""

# Create terraform directory if it doesn't exist
mkdir -p "$TERRAFORM_DIR/environments"

# =============================================================================
# Create main.tf
# =============================================================================
echo "üìù Creating terraform/main.tf..."
cat > "$TERRAFORM_DIR/main.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Main Configuration
# =============================================================================
# This file defines the core infrastructure for your application
# Generated by scripts/setup-terraform-lambda.sh
# =============================================================================

terraform {
  required_version = ">= 1.13"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  # Backend configuration is loaded from environments/*.hcl files
  # Initialize with: terraform init -backend-config=environments/dev-backend.hcl
  backend "s3" {
    # Backend config provided via -backend-config flag
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Project     = var.project_name
      Environment = var.environment
      ManagedBy   = "Terraform"
      Repository  = var.github_repo
    }
  }
}

# Get current AWS account ID
data "aws_caller_identity" "current" {}

# Get ECR repository (created by bootstrap)
data "aws_ecr_repository" "app" {
  name = var.ecr_repository_name
}
EOF

# =============================================================================
# Create variables.tf
# =============================================================================
echo "üìù Creating terraform/variables.tf..."
cat > "$TERRAFORM_DIR/variables.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Variables
# =============================================================================

variable "project_name" {
  description = "Project name (must match bootstrap configuration)"
  type        = string
}

variable "environment" {
  description = "Environment name (dev, test, prod)"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
}

variable "github_repo" {
  description = "GitHub repository name (org/repo)"
  type        = string
}

variable "ecr_repository_name" {
  description = "ECR repository name for Lambda container images"
  type        = string
}

variable "lambda_memory_size" {
  description = "Lambda function memory size in MB"
  type        = number
  default     = 512
}

variable "lambda_timeout" {
  description = "Lambda function timeout in seconds"
  type        = number
  default     = 30
}

variable "lambda_architecture" {
  description = "Lambda function architecture (x86_64 or arm64)"
  type        = string
  default     = "arm64"
}

# =============================================================================
# API Gateway Configuration (Standard Mode)
# =============================================================================

variable "enable_api_gateway_standard" {
  description = "Enable API Gateway as standard entry point (recommended for cloud deployments)"
  type        = bool
  default     = true
}

variable "enable_direct_access" {
  description = "Enable direct access URLs (Lambda Function URLs, App Runner direct). Set to true for local development."
  type        = bool
  default     = false
}

# Legacy variable for backward compatibility
variable "enable_api_gateway" {
  description = "DEPRECATED: Use enable_api_gateway_standard instead. Enable API Gateway for Lambda functions"
  type        = bool
  default     = true
}

# Rate Limiting / Throttling
variable "api_throttle_burst_limit" {
  description = "API Gateway throttle burst limit (requests)"
  type        = number
  default     = 5000
}

variable "api_throttle_rate_limit" {
  description = "API Gateway throttle rate limit (requests per second)"
  type        = number
  default     = 10000
}

# Logging and Monitoring
variable "api_log_retention_days" {
  description = "CloudWatch log retention for API Gateway logs (days)"
  type        = number
  default     = 7
}

variable "api_logging_level" {
  description = "API Gateway logging level (OFF, ERROR, INFO)"
  type        = string
  default     = "INFO"

  validation {
    condition     = contains(["OFF", "ERROR", "INFO"], var.api_logging_level)
    error_message = "Logging level must be OFF, ERROR, or INFO"
  }
}

variable "enable_api_data_trace" {
  description = "Enable full request/response data logging (verbose, use with caution)"
  type        = bool
  default     = false
}

variable "enable_xray_tracing" {
  description = "Enable AWS X-Ray tracing for API Gateway"
  type        = bool
  default     = false
}

# Caching
variable "enable_api_caching" {
  description = "Enable API Gateway caching"
  type        = bool
  default     = false
}

# CORS Configuration
variable "cors_allow_origins" {
  description = "CORS allowed origins"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_methods" {
  description = "CORS allowed HTTP methods"
  type        = list(string)
  default     = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
}

variable "cors_allow_headers" {
  description = "CORS allowed headers"
  type        = list(string)
  default     = ["Content-Type", "Authorization", "X-Requested-With"]
}

# =============================================================================
# API Key Authentication
# =============================================================================

variable "enable_api_key" {
  description = "Enable API Key authentication for API Gateway"
  type        = bool
  default     = true
}

variable "api_key_name" {
  description = "Name for the API Key (if enabled)"
  type        = string
  default     = ""
}

variable "api_usage_plan_quota_limit" {
  description = "Maximum number of requests per period (0 = unlimited)"
  type        = number
  default     = 0
}

variable "api_usage_plan_quota_period" {
  description = "Time period for quota (DAY, WEEK, MONTH)"
  type        = string
  default     = "MONTH"

  validation {
    condition     = contains(["DAY", "WEEK", "MONTH"], var.api_usage_plan_quota_period)
    error_message = "Quota period must be DAY, WEEK, or MONTH"
  }
}

variable "additional_tags" {
  description = "Additional tags to apply to resources"
  type        = map(string)
  default     = {}
}
EOF

# =============================================================================
# Create lambda-{service}.tf
# =============================================================================
LAMBDA_TF_FILE="$TERRAFORM_DIR/lambda-${SERVICE_NAME}.tf"

# Check if file already exists
if [ -f "$LAMBDA_TF_FILE" ]; then
  echo "‚ö†Ô∏è  Warning: ${LAMBDA_TF_FILE} already exists"
  read -p "Overwrite? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Skipping lambda-${SERVICE_NAME}.tf generation"
    echo "‚úÖ Setup completed (existing files preserved)"
    exit 0
  fi
fi

echo "üìù Creating ${LAMBDA_TF_FILE}..."
cat > "$LAMBDA_TF_FILE" <<'TEMPLATE_EOF'
# =============================================================================
# Lambda Service Configuration: SERVICE_NAME_PLACEHOLDER
# =============================================================================
# Generated by scripts/setup-terraform-lambda.sh
# This file defines the Lambda function for the SERVICE_NAME_PLACEHOLDER service
# =============================================================================

# Lambda execution role (from bootstrap)
data "aws_iam_role" "lambda_execution_SERVICE_NAME_PLACEHOLDER" {
  name = "\${var.project_name}-lambda-execution-role"
}

# Lambda function using container image
resource "aws_lambda_function" "SERVICE_NAME_PLACEHOLDER" {
  function_name = "\${var.project_name}-\${var.environment}-SERVICE_NAME_PLACEHOLDER"
  role          = data.aws_iam_role.lambda_execution_SERVICE_NAME_PLACEHOLDER.arn

  # Container image configuration
  package_type = "Image"
  # Using hierarchical tag format: SERVICE_NAME_PLACEHOLDER-{environment}-latest
  image_uri    = "\${data.aws_ecr_repository.app.repository_url}:SERVICE_NAME_PLACEHOLDER-\${var.environment}-latest"

  # Resource configuration
  memory_size = var.lambda_memory_size
  timeout     = var.lambda_timeout
  architectures = [var.lambda_architecture]

  # Environment variables
  environment {
    variables = {
      ENVIRONMENT   = var.environment
      PROJECT_NAME  = var.project_name
      SERVICE_NAME  = "SERVICE_NAME_PLACEHOLDER"
      LOG_LEVEL     = var.environment == "prod" ? "INFO" : "DEBUG"
    }
  }

  # Logging configuration
  logging_config {
    log_format = "JSON"
    log_group  = aws_cloudwatch_log_group.lambda_SERVICE_NAME_PLACEHOLDER.name
  }

  tags = {
    Name        = "\${var.project_name}-\${var.environment}-SERVICE_NAME_PLACEHOLDER"
    Service     = "SERVICE_NAME_PLACEHOLDER"
    Description = "SERVICE_NAME_PLACEHOLDER Lambda function"
  }

  # Note: Image must exist in ECR before first apply
  # Build and push with:
  #   ./scripts/docker-push.sh \${var.environment} SERVICE_NAME_PLACEHOLDER Dockerfile.lambda
  lifecycle {
    ignore_changes = [
      image_uri  # Allow image updates without Terraform (managed by CI/CD)
    ]
  }
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_SERVICE_NAME_PLACEHOLDER" {
  name              = "/aws/lambda/\${var.project_name}-\${var.environment}-SERVICE_NAME_PLACEHOLDER"
  retention_in_days = var.environment == "prod" ? 30 : 7

  tags = {
    Name    = "\${var.project_name}-\${var.environment}-SERVICE_NAME_PLACEHOLDER-logs"
    Service = "SERVICE_NAME_PLACEHOLDER"
  }
}

# Lambda Function URL (only when direct access is enabled)
resource "aws_lambda_function_url" "SERVICE_NAME_PLACEHOLDER" {
  count = var.enable_direct_access ? 1 : 0

  function_name      = aws_lambda_function.SERVICE_NAME_PLACEHOLDER.function_name
  authorization_type = "NONE"  # Change to "AWS_IAM" for authentication

  cors {
    allow_credentials = true
    allow_origins     = var.cors_allow_origins
    allow_methods     = var.cors_allow_methods
    allow_headers     = var.cors_allow_headers
    max_age          = 86400
  }
}

# =============================================================================
# Outputs for SERVICE_NAME_PLACEHOLDER Service
# =============================================================================

output "lambda_SERVICE_NAME_PLACEHOLDER_function_name" {
  description = "Name of the SERVICE_NAME_PLACEHOLDER Lambda function"
  value       = aws_lambda_function.SERVICE_NAME_PLACEHOLDER.function_name
}

output "lambda_SERVICE_NAME_PLACEHOLDER_function_arn" {
  description = "ARN of the SERVICE_NAME_PLACEHOLDER Lambda function"
  value       = aws_lambda_function.SERVICE_NAME_PLACEHOLDER.arn
}

output "lambda_SERVICE_NAME_PLACEHOLDER_url" {
  description = "Lambda Function URL for SERVICE_NAME_PLACEHOLDER service (only when direct access is enabled)"
  value       = var.enable_direct_access ? aws_lambda_function_url.SERVICE_NAME_PLACEHOLDER[0].function_url : null
}

output "lambda_SERVICE_NAME_PLACEHOLDER_log_group" {
  description = "CloudWatch Log Group for SERVICE_NAME_PLACEHOLDER service"
  value       = aws_cloudwatch_log_group.lambda_SERVICE_NAME_PLACEHOLDER.name
}
TEMPLATE_EOF

# Replace placeholders with actual service name
sed -i "s/SERVICE_NAME_PLACEHOLDER/${SERVICE_NAME}/g" "$LAMBDA_TF_FILE"

# =============================================================================
# Create api-gateway.tf (optional)
# =============================================================================
echo "üìù Creating terraform/api-gateway.tf..."
cat > "$TERRAFORM_DIR/api-gateway.tf" <<'EOF'
# =============================================================================
# API Gateway Configuration (Optional)
# =============================================================================
# Uncomment this file to use API Gateway instead of Lambda Function URLs
# =============================================================================

# API Gateway REST API
resource "aws_api_gateway_rest_api" "api" {
  count = var.enable_api_gateway ? 1 : 0

  name        = "${var.project_name}-${var.environment}-api"
  description = "API Gateway for ${var.project_name} ${var.environment}"

  endpoint_configuration {
    types = ["REGIONAL"]
  }
}

# Root resource proxy
resource "aws_api_gateway_resource" "proxy" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id = aws_api_gateway_rest_api.api[0].id
  parent_id   = aws_api_gateway_rest_api.api[0].root_resource_id
  path_part   = "{proxy+}"
}

# ANY method for proxy
resource "aws_api_gateway_method" "proxy" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id      = aws_api_gateway_rest_api.api[0].id
  resource_id      = aws_api_gateway_resource.proxy[0].id
  http_method      = "ANY"
  authorization    = "NONE"
  api_key_required = var.enable_api_key
}

# Lambda integration
resource "aws_api_gateway_integration" "lambda" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id = aws_api_gateway_rest_api.api[0].id
  resource_id = aws_api_gateway_method.proxy[0].resource_id
  http_method = aws_api_gateway_method.proxy[0].http_method

  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.api.invoke_arn
}

# Deployment
resource "aws_api_gateway_deployment" "api" {
  count = var.enable_api_gateway ? 1 : 0

  depends_on = [
    aws_api_gateway_integration.lambda
  ]

  rest_api_id = aws_api_gateway_rest_api.api[0].id

  lifecycle {
    create_before_destroy = true
  }
}

# Stage
resource "aws_api_gateway_stage" "api" {
  count = var.enable_api_gateway ? 1 : 0

  deployment_id = aws_api_gateway_deployment.api[0].id
  rest_api_id   = aws_api_gateway_rest_api.api[0].id
  stage_name    = var.environment
}

# Lambda permission for API Gateway
resource "aws_lambda_permission" "api_gateway" {
  count = var.enable_api_gateway ? 1 : 0

  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.api[0].execution_arn}/*/*"
}

# =============================================================================
# API Key Authentication (Optional)
# =============================================================================

# API Key
resource "aws_api_gateway_api_key" "api_key" {
  count = var.enable_api_gateway && var.enable_api_key ? 1 : 0

  name        = var.api_key_name != "" ? var.api_key_name : "${var.project_name}-${var.environment}-api-key"
  description = "API Key for ${var.project_name} ${var.environment} API"
  enabled     = true

  tags = {
    Name        = var.api_key_name != "" ? var.api_key_name : "${var.project_name}-${var.environment}-api-key"
    Project     = var.project_name
    Environment = var.environment
  }
}

# Usage Plan
resource "aws_api_gateway_usage_plan" "usage_plan" {
  count = var.enable_api_gateway && var.enable_api_key ? 1 : 0

  name        = "${var.project_name}-${var.environment}-usage-plan"
  description = "Usage plan for ${var.project_name} ${var.environment} API"

  api_stages {
    api_id = aws_api_gateway_rest_api.api[0].id
    stage  = aws_api_gateway_stage.api[0].stage_name
  }

  # Quota (optional)
  dynamic "quota_settings" {
    for_each = var.api_usage_plan_quota_limit > 0 ? [1] : []
    content {
      limit  = var.api_usage_plan_quota_limit
      period = var.api_usage_plan_quota_period
    }
  }

  tags = {
    Name        = "${var.project_name}-${var.environment}-usage-plan"
    Project     = var.project_name
    Environment = var.environment
  }
}

# Associate API Key with Usage Plan
resource "aws_api_gateway_usage_plan_key" "usage_plan_key" {
  count = var.enable_api_gateway && var.enable_api_key ? 1 : 0

  key_id        = aws_api_gateway_api_key.api_key[0].id
  key_type      = "API_KEY"
  usage_plan_id = aws_api_gateway_usage_plan.usage_plan[0].id
}
EOF

# =============================================================================
# Create outputs.tf (only if it doesn't exist)
# =============================================================================
if [ ! -f "$TERRAFORM_DIR/outputs.tf" ]; then
  echo "üìù Creating terraform/outputs.tf..."
  cat > "$TERRAFORM_DIR/outputs.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Outputs
# =============================================================================
# NOTE: Service-specific outputs (Lambda functions, URLs, etc.) are defined
# in each lambda-{service}.tf file. This file contains only shared outputs.
# =============================================================================

locals {
  api_gateway_enabled = var.enable_api_gateway_standard || var.enable_api_gateway
}

# =============================================================================
# API Gateway Outputs (Simplified)
# =============================================================================

output "api_gateway_url" {
  description = "API Gateway endpoint URL (standard entry point)"
  value       = local.api_gateway_enabled ? aws_api_gateway_stage.api[0].invoke_url : "Not enabled"
}

output "api_gateway_id" {
  description = "API Gateway REST API ID"
  value       = local.api_gateway_enabled ? aws_api_gateway_rest_api.api[0].id : "Not enabled"
}

output "api_gateway_stage" {
  description = "API Gateway stage name"
  value       = local.api_gateway_enabled ? aws_api_gateway_stage.api[0].stage_name : "Not enabled"
}

output "api_key_id" {
  description = "API Key ID (if enabled)"
  value       = local.api_gateway_enabled && var.enable_api_key ? aws_api_gateway_api_key.api_key[0].id : "Not enabled"
}

output "api_key_value" {
  description = "API Key value (sensitive, if enabled)"
  value       = local.api_gateway_enabled && var.enable_api_key ? aws_api_gateway_api_key.api_key[0].value : null
  sensitive   = true
}

# =============================================================================
# Common Outputs
# =============================================================================

output "ecr_repository_url" {
  description = "ECR repository URL for container images"
  value       = data.aws_ecr_repository.app.repository_url
}

output "environment" {
  description = "Current environment"
  value       = var.environment
}

output "deployment_mode" {
  description = "Current deployment mode (api-gateway-standard or direct-access)"
  value       = var.enable_api_gateway_standard ? "api-gateway-standard" : (var.enable_direct_access ? "direct-access" : "legacy-api-gateway")
}

output "primary_endpoint" {
  description = "Primary application endpoint (API Gateway, if enabled)"
  value       = local.api_gateway_enabled ? aws_api_gateway_stage.api[0].invoke_url : "Not enabled - use service-specific Function URLs"
}

# =============================================================================
# Service-Specific Outputs
# =============================================================================
# Individual Lambda service outputs are defined in lambda-{service}.tf files:
# - lambda_{service}_function_name
# - lambda_{service}_function_arn
# - lambda_{service}_url
# - lambda_{service}_log_group
# =============================================================================
EOF
else
  echo "‚ÑπÔ∏è  Skipping outputs.tf (already exists)"
fi

# =============================================================================
# Create environment-specific tfvars files
# =============================================================================
for ENV in "${ENVIRONMENTS[@]}"; do
  echo "üìù Creating terraform/environments/${ENV}.tfvars..."

  cat > "$TERRAFORM_DIR/environments/${ENV}.tfvars" <<EOF
# =============================================================================
# Application Infrastructure - ${ENV} Environment
# =============================================================================
# Generated by scripts/setup-terraform-lambda.sh
# Customize these values for your ${ENV} environment
# =============================================================================

project_name = "${PROJECT_NAME}"
environment  = "${ENV}"
aws_region   = "${AWS_REGION}"
github_repo  = "${GITHUB_ORG}/${GITHUB_REPO}"  # From bootstrap configuration

# ECR Repository (created by bootstrap)
ecr_repository_name = "${PROJECT_NAME}"  # Must match bootstrap configuration

# Lambda Configuration
lambda_memory_size  = $([ "$ENV" = "prod" ] && echo "1024" || echo "512")
lambda_timeout      = $([ "$ENV" = "prod" ] && echo "60" || echo "30")
lambda_architecture = "arm64"  # or "x86_64"

# =============================================================================
# API Gateway Configuration (Standard Mode)
# =============================================================================
# API Gateway is the standard entry point for cloud deployments
# For local development, set enable_direct_access = true

enable_api_gateway_standard = true   # Enable API Gateway as standard entry point
enable_direct_access        = false  # Disable direct Lambda URLs (cloud deployment)

# Rate Limiting
api_throttle_burst_limit = $([ "$ENV" = "prod" ] && echo "5000" || echo "1000")  # Burst limit
api_throttle_rate_limit  = $([ "$ENV" = "prod" ] && echo "10000" || echo "500")  # Requests per second

# Logging $([ "$ENV" = "prod" ] && echo "(standard for prod)" || echo "(verbose for ${ENV})")
api_log_retention_days = $([ "$ENV" = "prod" ] && echo "30" || echo "7")
api_logging_level      = "INFO"
enable_api_data_trace  = false  # Set to true for detailed request/response logging
enable_xray_tracing    = $([ "$ENV" = "prod" ] && echo "false" || echo "true")   # Enable X-Ray for debugging

# Caching $([ "$ENV" = "prod" ] && echo "(consider enabling for prod)" || echo "(disabled for ${ENV})")
enable_api_caching = false

# CORS $([ "$ENV" = "prod" ] && echo "(restrictive for prod)" || echo "(open for ${ENV})")
cors_allow_origins = $([ "$ENV" = "prod" ] && echo '["https://yourdomain.com"]' || echo '["*"]')
cors_allow_methods = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
cors_allow_headers = ["Content-Type", "Authorization", "X-Requested-With"]

# API Key Authentication (Optional)
enable_api_key              = ${ENABLE_API_KEY}  # Set to true to enable API Key authentication
api_key_name                = ""     # Auto-generated if not specified
api_usage_plan_quota_limit  = 0      # Max requests per period (0 = unlimited)
api_usage_plan_quota_period = "MONTH" # DAY, WEEK, or MONTH

# Additional tags
additional_tags = {
  CostCenter = "engineering"
  Team       = "platform"
}
EOF
done

# =============================================================================
# Create README
# =============================================================================
echo "üìù Creating terraform/README.md..."
cat > "$TERRAFORM_DIR/README.md" <<EOF
# Application Infrastructure

This directory contains Terraform configuration for your application infrastructure.

## Structure

- \`main.tf\` - Main Terraform configuration and provider setup
- \`variables.tf\` - Variable definitions
- \`lambda.tf\` - Lambda function resources
- \`api-gateway.tf\` - API Gateway configuration (optional)
- \`outputs.tf\` - Output values
- \`environments/\` - Environment-specific variable files
  - \`dev.tfvars\` - Development environment
  - \`test.tfvars\` - Test environment
  - \`prod.tfvars\` - Production environment
  - \`*-backend.hcl\` - Backend configurations (generated by \`make setup-terraform-backend\`)

## Prerequisites

1. Bootstrap infrastructure must be deployed first:
   \`\`\`bash
   make bootstrap-create
   make bootstrap-init
   make bootstrap-apply
   make setup-terraform-backend
   \`\`\`

2. Docker image must be built and pushed to ECR:
   \`\`\`bash
   make docker-build
   make docker-push-dev
   \`\`\`

## Usage

### Development Environment

\`\`\`bash
# Initialize Terraform
make app-init-dev

# Plan changes
make app-plan-dev

# Apply changes
make app-apply-dev

# View outputs
cd terraform && terraform output
\`\`\`

### Production Environment

\`\`\`bash
make app-init-prod
make app-plan-prod
make app-apply-prod
\`\`\`

## Customization

1. Edit \`environments/{env}.tfvars\` to customize settings per environment
2. Modify \`lambda.tf\` to add more Lambda functions
3. Enable API Gateway by setting \`enable_api_gateway = true\` in tfvars
4. Add more resources as needed (databases, queues, etc.)

## Notes

- Lambda functions use container images from ECR
- CloudWatch Logs are automatically configured
- Lambda Function URLs are enabled by default (no API Gateway needed)
- First apply will fail if Docker image doesn't exist in ECR
EOF

echo ""
echo "‚úÖ Lambda service '${SERVICE_NAME}' Terraform configuration created successfully!"
echo ""
echo "üìÇ Created/Updated files:"
if [ ! -f "$TERRAFORM_DIR/main.tf" ]; then
  echo "   terraform/main.tf"
  echo "   terraform/variables.tf"
  echo "   terraform/api-gateway.tf"
  echo "   terraform/outputs.tf"
  echo "   terraform/README.md"
  for ENV in "${ENVIRONMENTS[@]}"; do
    echo "   terraform/environments/${ENV}.tfvars"
  done
fi
echo "   terraform/lambda-${SERVICE_NAME}.tf ‚ú® NEW"
echo ""
echo "‚úÖ Service '${SERVICE_NAME}' configuration complete!"
echo ""
echo "=================================================="
echo "‚ö†Ô∏è  IMPORTANT: Deploy via GitHub Actions Only"
echo "=================================================="
echo ""
echo "All AWS deployments MUST be done through GitHub Actions."
echo ""
echo "üìã Recommended deployment workflow:"
echo ""
echo "1. Review and customize the generated files:"
echo "   vim terraform/environments/dev.tfvars"
echo "   - Update github_repo with your actual repository"
echo "   - Adjust Lambda memory/timeout settings as needed"
echo ""
echo "2. Ensure bootstrap infrastructure is deployed:"
echo "   make bootstrap-apply"
echo "   make setup-terraform-backend"
echo ""
echo "3. Configure GitHub repository secrets (from bootstrap output):"
echo "   make bootstrap-output  # Shows role ARNs, bucket names"
echo "   - Add AWS_ACCOUNT_ID and AWS_REGION to repository secrets"
echo "   - Add AWS_ROLE_ARN_DEV to dev environment secrets"
echo "   - Add AWS_ROLE_ARN_PROD to production environment secrets"
echo ""
echo "4. Deploy via GitHub Actions:"
echo "   git add ."
echo "   git commit -m 'feat: Add Lambda infrastructure'"
echo "   git push origin main"
echo ""
echo "   GitHub Actions will automatically:"
echo "   - Run tests"
echo "   - Build arm64 Docker image"
echo "   - Push to ECR"
echo "   - Deploy infrastructure with Terraform"
echo "   - Run smoke tests"
echo ""
echo "5. Monitor deployment:"
echo "   https://github.com/<YOUR-ORG>/<YOUR-REPO>/actions"
echo ""
echo "6. Deploy to production (when ready):"
echo "   git tag v1.0.0"
echo "   git push origin v1.0.0"
echo ""
echo "=================================================="
echo "üöÄ Next Steps for '${SERVICE_NAME}' Service"
echo "=================================================="
echo ""
echo "1. Build and push Docker image:"
echo "   ./scripts/docker-push.sh dev ${SERVICE_NAME} Dockerfile.lambda"
echo ""
echo "2. Deploy infrastructure:"
echo "   make app-init-dev app-apply-dev"
echo ""
echo "3. Test the deployed service:"
echo "   # Get service URL"
echo "   cd terraform && terraform output lambda_${SERVICE_NAME}_url"
echo ""
echo "   # Test the service"
echo "   curl \$(cd terraform && terraform output -raw lambda_${SERVICE_NAME}_url)/health"
echo ""
echo "   # Or use AWS CLI to invoke"
echo "   aws lambda invoke \\"
echo "     --function-name \$(cd terraform && terraform output -raw lambda_${SERVICE_NAME}_function_name) \\"
echo "     --payload '{\"path\":\"/health\"}' /tmp/response.json"
echo ""
echo "=================================================="
echo "üí° Why use GitHub Actions?"
echo "=================================================="
echo "- ‚úÖ Consistent arm64 builds (no QEMU/emulation issues)"
echo "- ‚úÖ Automated testing before deployment"
echo "- ‚úÖ Complete audit trail of changes"
echo "- ‚úÖ No manual AWS credential management"
echo "- ‚úÖ Reproducible deployments across team"
echo ""
echo "For more details, see: README.md#deploy-to-aws"
echo ""
