"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from enum import IntEnum
from typing import Generic, Optional, Sequence, TypeVar
from opentelemetry.sdk.metrics._internal.exemplar import ExemplarReservoirBuilder
from opentelemetry.sdk.metrics._internal.measurement import Measurement
from opentelemetry.sdk.metrics._internal.point import Gauge as GaugePoint, Histogram as HistogramPoint, HistogramDataPoint, NumberDataPoint, Sum
from opentelemetry.util.types import Attributes

_DataPointVarT = TypeVar("_DataPointVarT", NumberDataPoint, HistogramDataPoint)
_logger = ...
class AggregationTemporality(IntEnum):
    """
    The temporality to use when aggregating data.

    Can be one of the following values:
    """
    UNSPECIFIED = ...
    DELTA = ...
    CUMULATIVE = ...


class _Aggregation(ABC, Generic[_DataPointVarT]):
    def __init__(self, attributes: Attributes, reservoir_builder: ExemplarReservoirBuilder) -> None:
        ...
    
    @abstractmethod
    def aggregate(self, measurement: Measurement, should_sample_exemplar: bool = ...) -> None:
        """Aggregate a measurement.

        Args:
            measurement: Measurement to aggregate
            should_sample_exemplar: Whether the measurement should be sampled by the exemplars reservoir or not.
        """
        ...
    
    @abstractmethod
    def collect(self, collection_aggregation_temporality: AggregationTemporality, collection_start_nano: int) -> Optional[_DataPointVarT]:
        ...
    


class _DropAggregation(_Aggregation):
    def aggregate(self, measurement: Measurement, should_sample_exemplar: bool = ...) -> None:
        ...
    
    def collect(self, collection_aggregation_temporality: AggregationTemporality, collection_start_nano: int) -> Optional[_DataPointVarT]:
        ...
    


class _SumAggregation(_Aggregation[Sum]):
    def __init__(self, attributes: Attributes, instrument_is_monotonic: bool, instrument_aggregation_temporality: AggregationTemporality, start_time_unix_nano: int, reservoir_builder: ExemplarReservoirBuilder) -> None:
        ...
    
    def aggregate(self, measurement: Measurement, should_sample_exemplar: bool = ...) -> None:
        ...
    
    def collect(self, collection_aggregation_temporality: AggregationTemporality, collection_start_nano: int) -> Optional[NumberDataPoint]:
        """
        Atomically return a point for the current value of the metric and
        reset the aggregation value.

        Synchronous instruments have a method which is called directly with
        increments for a given quantity:

        For example, an instrument that counts the amount of passengers in
        every vehicle that crosses a certain point in a highway:

        synchronous_instrument.add(2)
        collect(...)  # 2 passengers are counted
        synchronous_instrument.add(3)
        collect(...)  # 3 passengers are counted
        synchronous_instrument.add(1)
        collect(...)  # 1 passenger is counted

        In this case the instrument aggregation temporality is DELTA because
        every value represents an increment to the count,

        Asynchronous instruments have a callback which returns the total value
        of a given quantity:

        For example, an instrument that measures the amount of bytes written to
        a certain hard drive:

        callback() -> 1352
        collect(...) # 1352 bytes have been written so far
        callback() -> 2324
        collect(...) # 2324 bytes have been written so far
        callback() -> 4542
        collect(...) # 4542 bytes have been written so far

        In this case the instrument aggregation temporality is CUMULATIVE
        because every value represents the total of the measurement.

        There is also the collection aggregation temporality, which is passed
        to this method. The collection aggregation temporality defines the
        nature of the returned value by this aggregation.

        When the collection aggregation temporality matches the
        instrument aggregation temporality, then this method returns the
        current value directly:

        synchronous_instrument.add(2)
        collect(DELTA) -> 2
        synchronous_instrument.add(3)
        collect(DELTA) -> 3
        synchronous_instrument.add(1)
        collect(DELTA) -> 1

        callback() -> 1352
        collect(CUMULATIVE) -> 1352
        callback() -> 2324
        collect(CUMULATIVE) -> 2324
        callback() -> 4542
        collect(CUMULATIVE) -> 4542

        When the collection aggregation temporality does not match the
        instrument aggregation temporality, then a conversion is made. For this
        purpose, this aggregation keeps a private attribute,
        self._previous_value.

        When the instrument is synchronous:

        self._previous_value is the sum of every previously
        collected (delta) value. In this case, the returned (cumulative) value
        will be:

        self._previous_value + value

        synchronous_instrument.add(2)
        collect(CUMULATIVE) -> 2
        synchronous_instrument.add(3)
        collect(CUMULATIVE) -> 5
        synchronous_instrument.add(1)
        collect(CUMULATIVE) -> 6

        Also, as a diagram:

        time ->

        self._previous_value
        |-------------|

        value (delta)
                      |----|

        returned value (cumulative)
        |------------------|

        When the instrument is asynchronous:

        self._previous_value is the value of the previously
        collected (cumulative) value. In this case, the returned (delta) value
        will be:

        value - self._previous_value

        callback() -> 1352
        collect(DELTA) -> 1352
        callback() -> 2324
        collect(DELTA) -> 972
        callback() -> 4542
        collect(DELTA) -> 2218

        Also, as a diagram:

        time ->

        self._previous_value
        |-------------|

        value (cumulative)
        |------------------|

        returned value (delta)
                      |----|
        """
        ...
    


class _LastValueAggregation(_Aggregation[GaugePoint]):
    def __init__(self, attributes: Attributes, reservoir_builder: ExemplarReservoirBuilder) -> None:
        ...
    
    def aggregate(self, measurement: Measurement, should_sample_exemplar: bool = ...): # -> None:
        ...
    
    def collect(self, collection_aggregation_temporality: AggregationTemporality, collection_start_nano: int) -> Optional[_DataPointVarT]:
        """
        Atomically return a point for the current value of the metric.
        """
        ...
    


_DEFAULT_EXPLICIT_BUCKET_HISTOGRAM_AGGREGATION_BOUNDARIES: Sequence[float] = ...
class _ExplicitBucketHistogramAggregation(_Aggregation[HistogramPoint]):
    def __init__(self, attributes: Attributes, instrument_aggregation_temporality: AggregationTemporality, start_time_unix_nano: int, reservoir_builder: ExemplarReservoirBuilder, boundaries: Optional[Sequence[float]] = ..., record_min_max: bool = ...) -> None:
        ...
    
    def aggregate(self, measurement: Measurement, should_sample_exemplar: bool = ...) -> None:
        ...
    
    def collect(self, collection_aggregation_temporality: AggregationTemporality, collection_start_nano: int) -> Optional[_DataPointVarT]:
        """
        Atomically return a point for the current value of the metric.
        """
        ...
    


class _ExponentialBucketHistogramAggregation(_Aggregation[HistogramPoint]):
    _min_max_size = ...
    _max_max_size = ...
    def __init__(self, attributes: Attributes, reservoir_builder: ExemplarReservoirBuilder, instrument_aggregation_temporality: AggregationTemporality, start_time_unix_nano: int, max_size: int = ..., max_scale: int = ...) -> None:
        ...
    
    def aggregate(self, measurement: Measurement, should_sample_exemplar: bool = ...) -> None:
        ...
    
    def collect(self, collection_aggregation_temporality: AggregationTemporality, collection_start_nano: int) -> Optional[_DataPointVarT]:
        """
        Atomically return a point for the current value of the metric.
        """
        ...
    


class Aggregation(ABC):
    """
    Base class for all aggregation types.
    """
    ...


class DefaultAggregation(Aggregation):
    """
    The default aggregation to be used in a `View`.

    This aggregation will create an actual aggregation depending on the
    instrument type, as specified next:

    ==================================================== ====================================
    Instrument                                           Aggregation
    ==================================================== ====================================
    `opentelemetry.sdk.metrics.Counter`                  `SumAggregation`
    `opentelemetry.sdk.metrics.UpDownCounter`            `SumAggregation`
    `opentelemetry.sdk.metrics.ObservableCounter`        `SumAggregation`
    `opentelemetry.sdk.metrics.ObservableUpDownCounter`  `SumAggregation`
    `opentelemetry.sdk.metrics.Histogram`                `ExplicitBucketHistogramAggregation`
    `opentelemetry.sdk.metrics.ObservableGauge`          `LastValueAggregation`
    ==================================================== ====================================
    """
    ...


class ExponentialBucketHistogramAggregation(Aggregation):
    def __init__(self, max_size: int = ..., max_scale: int = ...) -> None:
        ...
    


class ExplicitBucketHistogramAggregation(Aggregation):
    """This aggregation informs the SDK to collect:

    - Count of Measurement values falling within explicit bucket boundaries.
    - Arithmetic sum of Measurement values in population. This SHOULD NOT be collected when used with instruments that record negative measurements, e.g. UpDownCounter or ObservableGauge.
    - Min (optional) Measurement value in population.
    - Max (optional) Measurement value in population.


    Args:
        boundaries: Array of increasing values representing explicit bucket boundary values.
        record_min_max: Whether to record min and max.
    """
    def __init__(self, boundaries: Optional[Sequence[float]] = ..., record_min_max: bool = ...) -> None:
        ...
    


class SumAggregation(Aggregation):
    """This aggregation informs the SDK to collect:

    - The arithmetic sum of Measurement values.
    """
    ...


class LastValueAggregation(Aggregation):
    """
    This aggregation informs the SDK to collect:

    - The last Measurement.
    - The timestamp of the last Measurement.
    """
    ...


class DropAggregation(Aggregation):
    """Using this aggregation will make all measurements be ignored."""
    ...


