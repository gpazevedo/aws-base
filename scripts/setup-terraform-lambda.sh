#!/bin/bash
# =============================================================================
# Generate Lambda Service Terraform Configuration
# =============================================================================
# This script creates Terraform files for deploying Lambda functions.
# It creates lambda-variables.tf (if it doesn't exist) with Lambda-specific
# variables, and creates lambda-{service}.tf for each service.
#
# Prerequisites: Run ./scripts/setup-terraform-base.sh first
#
# Usage: ./scripts/setup-terraform-lambda.sh [SERVICE_NAME] [ENABLE_API_KEY]
#
# Examples:
#   ./scripts/setup-terraform-lambda.sh api false          # Create lambda-api.tf
#   ./scripts/setup-terraform-lambda.sh worker true        # Create lambda-worker.tf
#   ./scripts/setup-terraform-lambda.sh                    # Create lambda-api.tf (default)
# =============================================================================

set -e

# Parse command line arguments
SERVICE_NAME="${1:-api}"        # Default: 'api' for backward compatibility
ENABLE_API_KEY="${2:-true}"     # Default: enabled

TERRAFORM_DIR="terraform"
BOOTSTRAP_DIR="bootstrap"
ENVIRONMENTS=("dev" "test" "prod")

echo "üöÄ Setting up Lambda service Terraform configuration..."
echo ""

# =============================================================================
# Validate Service Directory
# =============================================================================

# Check if service directory exists in backend/
if [ ! -d "backend/${SERVICE_NAME}" ]; then
  echo "‚ùå Error: Service directory not found: backend/${SERVICE_NAME}"
  echo ""
  echo "Available services in backend/:"
  ls -d backend/*/ 2>/dev/null | xargs -n1 basename | grep -v "^$" || echo "  None found"
  echo ""
  echo "To create a new service, first create the directory:"
  echo "  mkdir -p backend/${SERVICE_NAME}"
  echo "  cp -r backend/api/* backend/${SERVICE_NAME}/"
  echo "  # Then customize backend/${SERVICE_NAME}/main.py for your service"
  exit 1
fi

echo "‚úÖ Service directory found: backend/${SERVICE_NAME}"
echo ""

# =============================================================================
# Check Prerequisites
# =============================================================================

# Check if base Terraform files exist
if [ ! -f "$TERRAFORM_DIR/main.tf" ] || [ ! -f "$TERRAFORM_DIR/variables.tf" ]; then
  echo "‚ùå Error: Base Terraform configuration not found"
  echo ""
  echo "Please run setup-terraform-base.sh first:"
  echo "  ./scripts/setup-terraform-base.sh"
  echo ""
  exit 1
fi

# =============================================================================
# Check Bootstrap Configuration
# =============================================================================

if [ ! -f "$BOOTSTRAP_DIR/terraform.tfvars" ]; then
  echo "‚ö†Ô∏è  Warning: Bootstrap terraform.tfvars not found"
  echo "   Using default values for examples"
  echo "   You should run bootstrap first: cp bootstrap/terraform.tfvars.example bootstrap/terraform.tfvars"
  echo ""
  PROJECT_NAME="<YOUR-PROJECT>"
  AWS_REGION="us-east-1"
else
  # Read configuration from bootstrap
  PROJECT_NAME=$(grep '^project_name' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  AWS_REGION=$(grep '^aws_region' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_ORG=$(grep '^github_org' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_REPO=$(grep '^github_repo' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
fi

# Set defaults if not found
: ${GITHUB_ORG:="<YOUR-ORG>"}
: ${GITHUB_REPO:="<YOUR-REPO>"}

echo "üìã Configuration:"
echo "   Service: $SERVICE_NAME"
echo "   Project: $PROJECT_NAME"
echo "   Region: $AWS_REGION"
echo "   GitHub: $GITHUB_ORG/$GITHUB_REPO"
echo "   API Key: $ENABLE_API_KEY"
echo ""

# =============================================================================
# Create lambda-variables.tf (Lambda-Specific Variables Only)
# =============================================================================
LAMBDA_VARS_FILE="$TERRAFORM_DIR/lambda-variables.tf"

if [ ! -f "$LAMBDA_VARS_FILE" ]; then
  echo "üìù Creating terraform/lambda-variables.tf..."
  cat > "$LAMBDA_VARS_FILE" <<'EOF'
# =============================================================================
# Lambda Service Variables
# =============================================================================
# Generated by scripts/setup-terraform-lambda.sh
# These variables are specific to Lambda services
# Common variables are in variables.tf
# =============================================================================

variable "lambda_architecture" {
  description = "Lambda function architecture (x86_64 or arm64)"
  type        = string
  default     = "arm64"
}

variable "lambda_memory_size" {
  description = "Default Lambda function memory size in MB (used when not specified per-service)"
  type        = number
  default     = 512
}

variable "lambda_timeout" {
  description = "Default Lambda function timeout in seconds (used when not specified per-service)"
  type        = number
  default     = 30
}

# =============================================================================
# Per-Service Lambda Configuration (Optional)
# =============================================================================
# Use this to configure different settings for each Lambda service
# If not provided, defaults above will be used

variable "lambda_service_configs" {
  description = "Per-service Lambda configuration (memory_size, timeout, reserved_concurrency)"
  type = map(object({
    memory_size                    = number
    timeout                        = number
    reserved_concurrent_executions = number
  }))
  default = {
    api = {
      memory_size                    = 1024
      timeout                        = 300
      reserved_concurrent_executions = 10
    }
  }
}

# Example usage in environments/{env}.tfvars:
#
# lambda_service_configs = {
#   api = {
#     memory_size = 512
#     timeout     = 30
#   }
#   worker = {
#     memory_size                    = 1024
#     timeout                        = 300
#     reserved_concurrent_executions = 10
#   }
#   processor = {
#     memory_size = 3008
#     timeout     = 900
#   }
# }
EOF
  echo "‚úÖ Created terraform/lambda-variables.tf"
else
  echo "‚ÑπÔ∏è  Lambda variables file already exists (terraform/lambda-variables.tf)"
fi

# =============================================================================
# Update environment tfvars with Lambda-specific defaults
# =============================================================================
for ENV in "${ENVIRONMENTS[@]}"; do
  TFVARS_FILE="$TERRAFORM_DIR/environments/${ENV}.tfvars"

  if [ -f "$TFVARS_FILE" ]; then
    # Check if Lambda variables are already present
    if ! grep -q "^lambda_memory_size" "$TFVARS_FILE" 2>/dev/null; then
      echo "üìù Adding Lambda variables to $TFVARS_FILE..."

      cat >> "$TFVARS_FILE" <<EOF

# =============================================================================
# Lambda Configuration
# =============================================================================

lambda_memory_size  = $([ "$ENV" = "prod" ] && echo "1024" || echo "512")
lambda_timeout      = $([ "$ENV" = "prod" ] && echo "60" || echo "30")

# Per-service Lambda configuration (optional)
# lambda_service_configs = {
#   api = {
#     memory_size = 512
#     timeout     = 30
#   }
#   worker = {
#     memory_size                    = 1024
#     timeout                        = 300
#     reserved_concurrent_executions = 10
#   }
# }
EOF
    else
      echo "‚ÑπÔ∏è  Lambda variables already present in $TFVARS_FILE"
    fi
  fi
done

# =============================================================================
# Create lambda-{service}.tf
# =============================================================================
LAMBDA_TF_FILE="$TERRAFORM_DIR/lambda-${SERVICE_NAME}.tf"

# Check if file already exists
if [ -f "$LAMBDA_TF_FILE" ]; then
  echo "‚ö†Ô∏è  Warning: ${LAMBDA_TF_FILE} already exists"
  read -p "Overwrite? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Skipping lambda-${SERVICE_NAME}.tf generation"
    echo "‚úÖ Setup completed (existing files preserved)"
    exit 0
  fi
fi

echo "üìù Creating ${LAMBDA_TF_FILE}..."
cat > "$LAMBDA_TF_FILE" <<'TEMPLATE_EOF'
# =============================================================================
# Lambda Service Configuration: SERVICE_NAME_PLACEHOLDER
# =============================================================================
# Generated by scripts/setup-terraform-lambda.sh
# This file defines the Lambda function for the SERVICE_NAME_PLACEHOLDER service
# =============================================================================

# Lambda execution role (from bootstrap)
data "aws_iam_role" "lambda_execution_SERVICE_NAME_PLACEHOLDER" {
  name = "${var.project_name}-lambda-execution-role"
}

# Lambda function using container image
resource "aws_lambda_function" "SERVICE_NAME_PLACEHOLDER" {
  function_name = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER"
  role          = data.aws_iam_role.lambda_execution_SERVICE_NAME_PLACEHOLDER.arn

  # Container image configuration
  package_type = "Image"
  # Using hierarchical tag format: SERVICE_NAME_PLACEHOLDER-{environment}-latest
  image_uri    = "${data.aws_ecr_repository.app.repository_url}:SERVICE_NAME_PLACEHOLDER-${var.environment}-latest"

  # Resource configuration - uses per-service config if available, otherwise defaults
  memory_size = try(var.lambda_service_configs["SERVICE_NAME_PLACEHOLDER"].memory_size, var.lambda_memory_size)
  timeout     = try(var.lambda_service_configs["SERVICE_NAME_PLACEHOLDER"].timeout, var.lambda_timeout)
  architectures = [var.lambda_architecture]

  # Optional: Reserved concurrent executions (if configured per-service)
  reserved_concurrent_executions = try(var.lambda_service_configs["SERVICE_NAME_PLACEHOLDER"].reserved_concurrent_executions, null)

  # Environment variables
  environment {
    variables = {
      ENVIRONMENT   = var.environment
      PROJECT_NAME  = var.project_name
      SERVICE_NAME  = "SERVICE_NAME_PLACEHOLDER"
      LOG_LEVEL     = var.environment == "prod" ? "INFO" : "DEBUG"
    }
  }

  # Logging configuration
  logging_config {
    log_format = "JSON"
    log_group  = aws_cloudwatch_log_group.lambda_SERVICE_NAME_PLACEHOLDER.name
  }

  tags = {
    Name        = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER"
    Service     = "SERVICE_NAME_PLACEHOLDER"
    Description = "SERVICE_NAME_PLACEHOLDER Lambda function"
  }

  # Note: Image must exist in ECR before first apply
  # Build and push with:
  #   ./scripts/docker-push.sh ${var.environment} SERVICE_NAME_PLACEHOLDER Dockerfile.lambda
  lifecycle {
    ignore_changes = [
      image_uri  # Allow image updates without Terraform (managed by CI/CD)
    ]
  }
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_SERVICE_NAME_PLACEHOLDER" {
  name              = "/aws/lambda/${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER"
  retention_in_days = var.environment == "prod" ? 30 : 7

  tags = {
    Name    = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER-logs"
    Service = "SERVICE_NAME_PLACEHOLDER"
  }
}

# Lambda Function URL (only when direct access is enabled)
resource "aws_lambda_function_url" "SERVICE_NAME_PLACEHOLDER" {
  count = var.enable_direct_access ? 1 : 0

  function_name      = aws_lambda_function.SERVICE_NAME_PLACEHOLDER.function_name
  authorization_type = "NONE"  # Change to "AWS_IAM" for authentication

  cors {
    allow_credentials = true
    allow_origins     = var.cors_allow_origins
    allow_methods     = var.cors_allow_methods
    allow_headers     = var.cors_allow_headers
    max_age          = 86400
  }
}

# =============================================================================
# Outputs for SERVICE_NAME_PLACEHOLDER Service
# =============================================================================

output "lambda_SERVICE_NAME_PLACEHOLDER_function_name" {
  description = "Name of the SERVICE_NAME_PLACEHOLDER Lambda function"
  value       = aws_lambda_function.SERVICE_NAME_PLACEHOLDER.function_name
}

output "lambda_SERVICE_NAME_PLACEHOLDER_function_arn" {
  description = "ARN of the SERVICE_NAME_PLACEHOLDER Lambda function"
  value       = aws_lambda_function.SERVICE_NAME_PLACEHOLDER.arn
}

output "lambda_SERVICE_NAME_PLACEHOLDER_url" {
  description = "Lambda Function URL for SERVICE_NAME_PLACEHOLDER service (only when direct access is enabled)"
  value       = var.enable_direct_access ? aws_lambda_function_url.SERVICE_NAME_PLACEHOLDER[0].function_url : null
}

output "lambda_SERVICE_NAME_PLACEHOLDER_log_group" {
  description = "CloudWatch Log Group for SERVICE_NAME_PLACEHOLDER service"
  value       = aws_cloudwatch_log_group.lambda_SERVICE_NAME_PLACEHOLDER.name
}
TEMPLATE_EOF

# Replace placeholders with actual service name
sed -i "s/SERVICE_NAME_PLACEHOLDER/${SERVICE_NAME}/g" "$LAMBDA_TF_FILE"

# =============================================================================
# Smart API Gateway Integration Management
# =============================================================================
API_GATEWAY_FILE="$TERRAFORM_DIR/api-gateway.tf"

# Determine path_prefix based on service name
if [ "$SERVICE_NAME" = "api" ]; then
  PATH_PREFIX=""  # Root path for 'api' service
  ENABLE_ROOT="true"
else
  PATH_PREFIX="$SERVICE_NAME"  # Path-based for other services
  ENABLE_ROOT="false"
fi

# Check if this service integration already exists
if grep -q "module \"api_gateway_lambda_${SERVICE_NAME}\"" "$API_GATEWAY_FILE"; then
  echo "‚ÑπÔ∏è  Integration for '${SERVICE_NAME}' already exists in api-gateway.tf"
else
  echo "üìù Appending integration for '${SERVICE_NAME}' to api-gateway.tf..."

  cat >> "$API_GATEWAY_FILE" <<EOF

# Integration for '${SERVICE_NAME}' Lambda service
module "api_gateway_lambda_${SERVICE_NAME}" {
  source = "./modules/api-gateway-lambda-integration"
  count  = local.api_gateway_enabled ? 1 : 0

  service_name = "${SERVICE_NAME}"
  path_prefix  = "${PATH_PREFIX}"  # $([ -z "$PATH_PREFIX" ] && echo "Empty = root (/, /*)" || echo "/${PATH_PREFIX}, /${PATH_PREFIX}/*")

  api_id                = module.api_gateway_shared[0].api_id
  api_root_resource_id  = module.api_gateway_shared[0].root_resource_id
  api_execution_arn     = module.api_gateway_shared[0].execution_arn

  lambda_function_name  = aws_lambda_function.${SERVICE_NAME}.function_name
  lambda_invoke_arn     = aws_lambda_function.${SERVICE_NAME}.invoke_arn

  enable_root_method    = ${ENABLE_ROOT}
  api_key_required      = var.enable_api_key
}
EOF

  echo "‚úÖ Added integration for '${SERVICE_NAME}'"
fi

echo ""
echo "‚úÖ Lambda service '${SERVICE_NAME}' Terraform configuration created successfully!"
echo ""
echo "üìÇ Created/Updated files:"
echo "   terraform/lambda-variables.tf"
echo "   terraform/lambda-${SERVICE_NAME}.tf ‚ú®"
echo "   terraform/api-gateway.tf"
for ENV in "${ENVIRONMENTS[@]}"; do
  if [ -f "$TERRAFORM_DIR/environments/${ENV}.tfvars" ]; then
    echo "   terraform/environments/${ENV}.tfvars (updated)"
  fi
done
echo ""
echo "üöÄ Next Steps for '${SERVICE_NAME}' Service:"
echo ""
echo "1. Build and push Docker image:"
echo "   ./scripts/docker-push.sh dev ${SERVICE_NAME} Dockerfile.lambda"
echo ""
echo "2. Deploy infrastructure:"
echo "   make app-init-dev app-apply-dev"
echo ""
echo "3. Test the deployed service:"
echo "   PRIMARY_URL=\$(cd terraform && terraform output -raw primary_endpoint)"
if [ "$SERVICE_NAME" = "api" ]; then
  echo "   curl \$PRIMARY_URL/health"
else
  echo "   curl \$PRIMARY_URL/${SERVICE_NAME}/health"
fi
echo ""
echo "üí° To configure service-specific settings (memory, timeout, etc.):"
echo "   Edit terraform/environments/dev.tfvars and add to lambda_service_configs"
echo ""
