#!/bin/bash
# =============================================================================
# Generate Example Application Terraform Configuration
# =============================================================================
# This script creates example Terraform files for deploying Lambda functions
# in the terraform/ directory with environment-specific configurations
# =============================================================================

set -e

TERRAFORM_DIR="terraform"
BOOTSTRAP_DIR="bootstrap"
ENVIRONMENTS=("dev" "test" "prod")

echo "ðŸš€ Setting up example application Terraform configuration..."
echo ""

# Check if bootstrap has been initialized
if [ ! -f "$BOOTSTRAP_DIR/terraform.tfvars" ]; then
  echo "âš ï¸  Warning: Bootstrap terraform.tfvars not found"
  echo "   Using default values for examples"
  echo "   You should run bootstrap first: cp bootstrap/terraform.tfvars.example bootstrap/terraform.tfvars"
  echo ""
  PROJECT_NAME="my-project"
  AWS_REGION="us-east-1"
else
  # Read configuration from bootstrap
  PROJECT_NAME=$(grep '^project_name' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  AWS_REGION=$(grep '^aws_region' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_ORG=$(grep '^github_org' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_REPO=$(grep '^github_repo' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
fi

# Set defaults if not found
: ${GITHUB_ORG:="your-org"}
: ${GITHUB_REPO:="your-repo"}

echo "ðŸ“‹ Configuration:"
echo "   Project: $PROJECT_NAME"
echo "   Region: $AWS_REGION"
echo "   GitHub: $GITHUB_ORG/$GITHUB_REPO"
echo ""

# Create terraform directory if it doesn't exist
mkdir -p "$TERRAFORM_DIR/environments"

# =============================================================================
# Create main.tf
# =============================================================================
echo "ðŸ“ Creating terraform/main.tf..."
cat > "$TERRAFORM_DIR/main.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Main Configuration
# =============================================================================
# This file defines the core infrastructure for your application
# Generated by scripts/setup-terraform-lambda.sh
# =============================================================================

terraform {
  required_version = ">= 1.13"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  # Backend configuration is loaded from environments/*.hcl files
  # Initialize with: terraform init -backend-config=environments/dev-backend.hcl
  backend "s3" {
    # Backend config provided via -backend-config flag
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Project     = var.project_name
      Environment = var.environment
      ManagedBy   = "Terraform"
      Repository  = var.github_repo
    }
  }
}

# Get current AWS account ID
data "aws_caller_identity" "current" {}

# Get ECR repository (created by bootstrap)
data "aws_ecr_repository" "app" {
  name = var.ecr_repository_name
}
EOF

# =============================================================================
# Create variables.tf
# =============================================================================
echo "ðŸ“ Creating terraform/variables.tf..."
cat > "$TERRAFORM_DIR/variables.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Variables
# =============================================================================

variable "project_name" {
  description = "Project name (must match bootstrap configuration)"
  type        = string
}

variable "environment" {
  description = "Environment name (dev, test, prod)"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
}

variable "github_repo" {
  description = "GitHub repository name (org/repo)"
  type        = string
}

variable "ecr_repository_name" {
  description = "ECR repository name for Lambda container images"
  type        = string
}

variable "lambda_memory_size" {
  description = "Lambda function memory size in MB"
  type        = number
  default     = 512
}

variable "lambda_timeout" {
  description = "Lambda function timeout in seconds"
  type        = number
  default     = 30
}

variable "lambda_architecture" {
  description = "Lambda function architecture (x86_64 or arm64)"
  type        = string
  default     = "arm64"
}

# =============================================================================
# API Gateway Configuration (Standard Mode)
# =============================================================================

variable "enable_api_gateway_standard" {
  description = "Enable API Gateway as standard entry point (recommended for cloud deployments)"
  type        = bool
  default     = true
}

variable "enable_direct_access" {
  description = "Enable direct access URLs (Lambda Function URLs, App Runner direct). Set to true for local development."
  type        = bool
  default     = false
}

# Legacy variable for backward compatibility
variable "enable_api_gateway" {
  description = "DEPRECATED: Use enable_api_gateway_standard instead. Enable API Gateway for Lambda functions"
  type        = bool
  default     = true
}

# Rate Limiting / Throttling
variable "api_throttle_burst_limit" {
  description = "API Gateway throttle burst limit (requests)"
  type        = number
  default     = 5000
}

variable "api_throttle_rate_limit" {
  description = "API Gateway throttle rate limit (requests per second)"
  type        = number
  default     = 10000
}

# Logging and Monitoring
variable "api_log_retention_days" {
  description = "CloudWatch log retention for API Gateway logs (days)"
  type        = number
  default     = 7
}

variable "api_logging_level" {
  description = "API Gateway logging level (OFF, ERROR, INFO)"
  type        = string
  default     = "INFO"

  validation {
    condition     = contains(["OFF", "ERROR", "INFO"], var.api_logging_level)
    error_message = "Logging level must be OFF, ERROR, or INFO"
  }
}

variable "enable_api_data_trace" {
  description = "Enable full request/response data logging (verbose, use with caution)"
  type        = bool
  default     = false
}

variable "enable_xray_tracing" {
  description = "Enable AWS X-Ray tracing for API Gateway"
  type        = bool
  default     = false
}

# Caching
variable "enable_api_caching" {
  description = "Enable API Gateway caching"
  type        = bool
  default     = false
}

# CORS Configuration
variable "cors_allow_origins" {
  description = "CORS allowed origins"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_methods" {
  description = "CORS allowed HTTP methods"
  type        = list(string)
  default     = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
}

variable "cors_allow_headers" {
  description = "CORS allowed headers"
  type        = list(string)
  default     = ["Content-Type", "Authorization", "X-Requested-With"]
}

variable "additional_tags" {
  description = "Additional tags to apply to resources"
  type        = map(string)
  default     = {}
}
EOF

# =============================================================================
# Create lambda.tf
# =============================================================================
echo "ðŸ“ Creating terraform/lambda.tf..."
cat > "$TERRAFORM_DIR/lambda.tf" <<'EOF'
# =============================================================================
# Lambda Functions Configuration
# =============================================================================

# Lambda execution role (from bootstrap)
data "aws_iam_role" "lambda_execution" {
  name = "${var.project_name}-lambda-execution-role"
}

# Example Lambda function using container image
resource "aws_lambda_function" "api" {
  function_name = "${var.project_name}-${var.environment}-api"
  role          = data.aws_iam_role.lambda_execution.arn

  # Container image configuration
  package_type = "Image"
  # Using hierarchical tag format: api-{environment}-latest
  image_uri    = "${data.aws_ecr_repository.app.repository_url}:api-${var.environment}-latest"

  # Resource configuration
  memory_size = var.lambda_memory_size
  timeout     = var.lambda_timeout
  architectures = [var.lambda_architecture]

  # Environment variables
  environment {
    variables = {
      ENVIRONMENT   = var.environment
      PROJECT_NAME  = var.project_name
      LOG_LEVEL     = var.environment == "prod" ? "INFO" : "DEBUG"
    }
  }

  # Logging configuration
  logging_config {
    log_format = "JSON"
    log_group  = aws_cloudwatch_log_group.lambda_api.name
  }

  tags = {
    Name        = "${var.project_name}-${var.environment}-api"
    Description = "Main API Lambda function"
  }

  # Note: Image must exist in ECR before first apply
  # Build and push via GitHub Actions or manually:
  #   1. Build: cd backend && docker build --build-arg SERVICE_FOLDER=api --platform linux/arm64 -f Dockerfile.lambda -t myapp:latest .
  #   2. Push: Use GitHub Actions workflow or 'make docker-push-dev'
  lifecycle {
    ignore_changes = [
      image_uri  # Allow image updates without Terraform (managed by CI/CD)
    ]
  }
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_api" {
  name              = "/aws/lambda/${var.project_name}-${var.environment}-api"
  retention_in_days = var.environment == "prod" ? 30 : 7

  tags = {
    Name = "${var.project_name}-${var.environment}-api-logs"
  }
}

# Lambda Function URL (only when direct access is enabled)
resource "aws_lambda_function_url" "api" {
  count = var.enable_direct_access ? 1 : 0

  function_name      = aws_lambda_function.api.function_name
  authorization_type = "NONE"  # Change to "AWS_IAM" for authentication

  cors {
    allow_credentials = true
    allow_origins     = var.cors_allow_origins
    allow_methods     = var.cors_allow_methods
    allow_headers     = var.cors_allow_headers
    max_age          = 86400
  }
}
EOF

# =============================================================================
# Create api-gateway.tf (optional)
# =============================================================================
echo "ðŸ“ Creating terraform/api-gateway.tf..."
cat > "$TERRAFORM_DIR/api-gateway.tf" <<'EOF'
# =============================================================================
# API Gateway Configuration (Optional)
# =============================================================================
# Uncomment this file to use API Gateway instead of Lambda Function URLs
# =============================================================================

# API Gateway REST API
resource "aws_api_gateway_rest_api" "api" {
  count = var.enable_api_gateway ? 1 : 0

  name        = "${var.project_name}-${var.environment}-api"
  description = "API Gateway for ${var.project_name} ${var.environment}"

  endpoint_configuration {
    types = ["REGIONAL"]
  }
}

# Root resource proxy
resource "aws_api_gateway_resource" "proxy" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id = aws_api_gateway_rest_api.api[0].id
  parent_id   = aws_api_gateway_rest_api.api[0].root_resource_id
  path_part   = "{proxy+}"
}

# ANY method for proxy
resource "aws_api_gateway_method" "proxy" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id      = aws_api_gateway_rest_api.api[0].id
  resource_id      = aws_api_gateway_resource.proxy[0].id
  http_method      = "ANY"
  authorization    = "NONE"
  api_key_required = var.enable_api_key
}

# Lambda integration
resource "aws_api_gateway_integration" "lambda" {
  count = var.enable_api_gateway ? 1 : 0

  rest_api_id = aws_api_gateway_rest_api.api[0].id
  resource_id = aws_api_gateway_method.proxy[0].resource_id
  http_method = aws_api_gateway_method.proxy[0].http_method

  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.api.invoke_arn
}

# Deployment
resource "aws_api_gateway_deployment" "api" {
  count = var.enable_api_gateway ? 1 : 0

  depends_on = [
    aws_api_gateway_integration.lambda
  ]

  rest_api_id = aws_api_gateway_rest_api.api[0].id

  lifecycle {
    create_before_destroy = true
  }
}

# Stage
resource "aws_api_gateway_stage" "api" {
  count = var.enable_api_gateway ? 1 : 0

  deployment_id = aws_api_gateway_deployment.api[0].id
  rest_api_id   = aws_api_gateway_rest_api.api[0].id
  stage_name    = var.environment
}

# Lambda permission for API Gateway
resource "aws_lambda_permission" "api_gateway" {
  count = var.enable_api_gateway ? 1 : 0

  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.api[0].execution_arn}/*/*"
}

# =============================================================================
# API Key Authentication (Optional)
# =============================================================================

# API Key
resource "aws_api_gateway_api_key" "api_key" {
  count = var.enable_api_gateway && var.enable_api_key ? 1 : 0

  name        = var.api_key_name != "" ? var.api_key_name : "${var.project_name}-${var.environment}-api-key"
  description = "API Key for ${var.project_name} ${var.environment} API"
  enabled     = true

  tags = {
    Name        = var.api_key_name != "" ? var.api_key_name : "${var.project_name}-${var.environment}-api-key"
    Project     = var.project_name
    Environment = var.environment
  }
}

# Usage Plan
resource "aws_api_gateway_usage_plan" "usage_plan" {
  count = var.enable_api_gateway && var.enable_api_key ? 1 : 0

  name        = "${var.project_name}-${var.environment}-usage-plan"
  description = "Usage plan for ${var.project_name} ${var.environment} API"

  api_stages {
    api_id = aws_api_gateway_rest_api.api[0].id
    stage  = aws_api_gateway_stage.api[0].stage_name
  }

  # Quota (optional)
  dynamic "quota_settings" {
    for_each = var.api_usage_plan_quota_limit > 0 ? [1] : []
    content {
      limit  = var.api_usage_plan_quota_limit
      period = var.api_usage_plan_quota_period
    }
  }

  tags = {
    Name        = "${var.project_name}-${var.environment}-usage-plan"
    Project     = var.project_name
    Environment = var.environment
  }
}

# Associate API Key with Usage Plan
resource "aws_api_gateway_usage_plan_key" "usage_plan_key" {
  count = var.enable_api_gateway && var.enable_api_key ? 1 : 0

  key_id        = aws_api_gateway_api_key.api_key[0].id
  key_type      = "API_KEY"
  usage_plan_id = aws_api_gateway_usage_plan.usage_plan[0].id
}
EOF

# =============================================================================
# Create outputs.tf
# =============================================================================
echo "ðŸ“ Creating terraform/outputs.tf..."
cat > "$TERRAFORM_DIR/outputs.tf" <<'EOF'
# =============================================================================
# Application Infrastructure - Outputs
# =============================================================================
# NOTE: This is a simplified version for initial setup.
# For advanced setup with API Gateway modules, see the aws-base repository.
# =============================================================================

locals {
  api_gateway_enabled = var.enable_api_gateway_standard || var.enable_api_gateway
}

# =============================================================================
# Lambda Outputs
# =============================================================================

output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api.arn
}

output "lambda_function_url" {
  description = "Lambda Function URL endpoint (only when direct access is enabled)"
  value       = var.enable_direct_access ? aws_lambda_function_url.api[0].function_url : "Direct access disabled - use API Gateway"
}

output "cloudwatch_log_group_lambda" {
  description = "CloudWatch Log Group name for Lambda"
  value       = aws_cloudwatch_log_group.lambda_api.name
}

# =============================================================================
# API Gateway Outputs (Simplified)
# =============================================================================

output "api_gateway_url" {
  description = "API Gateway endpoint URL (standard entry point)"
  value       = local.api_gateway_enabled ? aws_api_gateway_stage.api[0].invoke_url : "Not enabled"
}

output "api_gateway_id" {
  description = "API Gateway REST API ID"
  value       = local.api_gateway_enabled ? aws_api_gateway_rest_api.api[0].id : "Not enabled"
}

output "api_gateway_stage" {
  description = "API Gateway stage name"
  value       = local.api_gateway_enabled ? aws_api_gateway_stage.api[0].stage_name : "Not enabled"
}

output "api_key_id" {
  description = "API Key ID (if enabled)"
  value       = local.api_gateway_enabled && var.enable_api_key ? aws_api_gateway_api_key.api_key[0].id : "Not enabled"
}

output "api_key_value" {
  description = "API Key value (sensitive, if enabled)"
  value       = local.api_gateway_enabled && var.enable_api_key ? aws_api_gateway_api_key.api_key[0].value : null
  sensitive   = true
}

# =============================================================================
# Common Outputs
# =============================================================================

output "ecr_repository_url" {
  description = "ECR repository URL for container images"
  value       = data.aws_ecr_repository.app.repository_url
}

output "environment" {
  description = "Current environment"
  value       = var.environment
}

output "deployment_mode" {
  description = "Current deployment mode (api-gateway-standard or direct-access)"
  value       = var.enable_api_gateway_standard ? "api-gateway-standard" : (var.enable_direct_access ? "direct-access" : "legacy-api-gateway")
}

output "primary_endpoint" {
  description = "Primary application endpoint (use this for accessing the application)"
  value = local.api_gateway_enabled ? aws_api_gateway_stage.api[0].invoke_url : (
    var.enable_direct_access ? aws_lambda_function_url.api[0].function_url : "No endpoint configured"
  )
}
EOF

# =============================================================================
# Create environment-specific tfvars files
# =============================================================================
for ENV in "${ENVIRONMENTS[@]}"; do
  echo "ðŸ“ Creating terraform/environments/${ENV}.tfvars..."

  cat > "$TERRAFORM_DIR/environments/${ENV}.tfvars" <<EOF
# =============================================================================
# Application Infrastructure - ${ENV} Environment
# =============================================================================
# Generated by scripts/setup-terraform-lambda.sh
# Customize these values for your ${ENV} environment
# =============================================================================

project_name = "${PROJECT_NAME}"
environment  = "${ENV}"
aws_region   = "${AWS_REGION}"
github_repo  = "${GITHUB_ORG}/${GITHUB_REPO}"  # From bootstrap configuration

# ECR Repository (created by bootstrap)
ecr_repository_name = "${PROJECT_NAME}"  # Must match bootstrap configuration

# Lambda Configuration
lambda_memory_size  = $([ "$ENV" = "prod" ] && echo "1024" || echo "512")
lambda_timeout      = $([ "$ENV" = "prod" ] && echo "60" || echo "30")
lambda_architecture = "arm64"  # or "x86_64"

# =============================================================================
# API Gateway Configuration (Standard Mode)
# =============================================================================
# API Gateway is the standard entry point for cloud deployments
# For local development, set enable_direct_access = true

enable_api_gateway_standard = true   # Enable API Gateway as standard entry point
enable_direct_access        = false  # Disable direct Lambda URLs (cloud deployment)

# Rate Limiting
api_throttle_burst_limit = $([ "$ENV" = "prod" ] && echo "5000" || echo "1000")  # Burst limit
api_throttle_rate_limit  = $([ "$ENV" = "prod" ] && echo "10000" || echo "500")  # Requests per second

# Logging $([ "$ENV" = "prod" ] && echo "(standard for prod)" || echo "(verbose for ${ENV})")
api_log_retention_days = $([ "$ENV" = "prod" ] && echo "30" || echo "7")
api_logging_level      = "INFO"
enable_api_data_trace  = false  # Set to true for detailed request/response logging
enable_xray_tracing    = $([ "$ENV" = "prod" ] && echo "false" || echo "true")   # Enable X-Ray for debugging

# Caching $([ "$ENV" = "prod" ] && echo "(consider enabling for prod)" || echo "(disabled for ${ENV})")
enable_api_caching = false

# CORS $([ "$ENV" = "prod" ] && echo "(restrictive for prod)" || echo "(open for ${ENV})")
cors_allow_origins = $([ "$ENV" = "prod" ] && echo '["https://yourdomain.com"]' || echo '["*"]')
cors_allow_methods = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
cors_allow_headers = ["Content-Type", "Authorization", "X-Requested-With"]

# API Key Authentication (Optional)
enable_api_key              = false  # Set to true to enable API Key authentication
api_key_name                = ""     # Auto-generated if not specified
api_usage_plan_quota_limit  = 0      # Max requests per period (0 = unlimited)
api_usage_plan_quota_period = "MONTH" # DAY, WEEK, or MONTH

# Additional tags
additional_tags = {
  CostCenter = "engineering"
  Team       = "platform"
}
EOF
done

# =============================================================================
# Create README
# =============================================================================
echo "ðŸ“ Creating terraform/README.md..."
cat > "$TERRAFORM_DIR/README.md" <<EOF
# Application Infrastructure

This directory contains Terraform configuration for your application infrastructure.

## Structure

- \`main.tf\` - Main Terraform configuration and provider setup
- \`variables.tf\` - Variable definitions
- \`lambda.tf\` - Lambda function resources
- \`api-gateway.tf\` - API Gateway configuration (optional)
- \`outputs.tf\` - Output values
- \`environments/\` - Environment-specific variable files
  - \`dev.tfvars\` - Development environment
  - \`test.tfvars\` - Test environment
  - \`prod.tfvars\` - Production environment
  - \`*-backend.hcl\` - Backend configurations (generated by \`make setup-terraform-backend\`)

## Prerequisites

1. Bootstrap infrastructure must be deployed first:
   \`\`\`bash
   make bootstrap-create
   make bootstrap-init
   make bootstrap-apply
   make setup-terraform-backend
   \`\`\`

2. Docker image must be built and pushed to ECR:
   \`\`\`bash
   make docker-build
   make docker-push-dev
   \`\`\`

## Usage

### Development Environment

\`\`\`bash
# Initialize Terraform
make app-init-dev

# Plan changes
make app-plan-dev

# Apply changes
make app-apply-dev

# View outputs
cd terraform && terraform output
\`\`\`

### Production Environment

\`\`\`bash
make app-init-prod
make app-plan-prod
make app-apply-prod
\`\`\`

## Customization

1. Edit \`environments/{env}.tfvars\` to customize settings per environment
2. Modify \`lambda.tf\` to add more Lambda functions
3. Enable API Gateway by setting \`enable_api_gateway = true\` in tfvars
4. Add more resources as needed (databases, queues, etc.)

## Notes

- Lambda functions use container images from ECR
- CloudWatch Logs are automatically configured
- Lambda Function URLs are enabled by default (no API Gateway needed)
- First apply will fail if Docker image doesn't exist in ECR
EOF

echo ""
echo "âœ… Application Terraform configuration created successfully!"
echo ""
echo "ðŸ“‚ Created files:"
echo "   terraform/main.tf"
echo "   terraform/variables.tf"
echo "   terraform/lambda.tf"
echo "   terraform/api-gateway.tf"
echo "   terraform/outputs.tf"
echo "   terraform/README.md"
for ENV in "${ENVIRONMENTS[@]}"; do
  echo "   terraform/environments/${ENV}.tfvars"
done
echo ""
echo "âœ… Application Terraform configuration created successfully!"
echo ""
echo "=================================================="
echo "âš ï¸  IMPORTANT: Deploy via GitHub Actions Only"
echo "=================================================="
echo ""
echo "All AWS deployments MUST be done through GitHub Actions."
echo ""
echo "ðŸ“‹ Recommended deployment workflow:"
echo ""
echo "1. Review and customize the generated files:"
echo "   vim terraform/environments/dev.tfvars"
echo "   - Update github_repo with your actual repository"
echo "   - Adjust Lambda memory/timeout settings as needed"
echo ""
echo "2. Ensure bootstrap infrastructure is deployed:"
echo "   make bootstrap-apply"
echo "   make setup-terraform-backend"
echo ""
echo "3. Configure GitHub repository secrets (from bootstrap output):"
echo "   make bootstrap-output  # Shows role ARNs, bucket names"
echo "   - Add AWS_ACCOUNT_ID and AWS_REGION to repository secrets"
echo "   - Add AWS_ROLE_ARN_DEV to dev environment secrets"
echo "   - Add AWS_ROLE_ARN_PROD to production environment secrets"
echo ""
echo "4. Deploy via GitHub Actions:"
echo "   git add ."
echo "   git commit -m 'feat: Add Lambda infrastructure'"
echo "   git push origin main"
echo ""
echo "   GitHub Actions will automatically:"
echo "   - Run tests"
echo "   - Build arm64 Docker image"
echo "   - Push to ECR"
echo "   - Deploy infrastructure with Terraform"
echo "   - Run smoke tests"
echo ""
echo "5. Monitor deployment:"
echo "   https://github.com/<your-org>/<your-repo>/actions"
echo ""
echo "6. Deploy to production (when ready):"
echo "   git tag v1.0.0"
echo "   git push origin v1.0.0"
echo ""
echo "=================================================="
echo "ðŸ’¡ Why use GitHub Actions?"
echo "=================================================="
echo "- âœ… Consistent arm64 builds (no QEMU/emulation issues)"
echo "- âœ… Automated testing before deployment"
echo "- âœ… Complete audit trail of changes"
echo "- âœ… No manual AWS credential management"
echo "- âœ… Reproducible deployments across team"
echo ""
echo "For more details, see: README.md#deploy-to-aws"
echo ""
