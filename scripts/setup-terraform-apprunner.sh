#!/bin/bash
# =============================================================================
# Generate App Runner Service Terraform Configuration
# =============================================================================
# This script creates Terraform files for deploying App Runner services.
# It creates apprunner-variables.tf (if it doesn't exist) with AppRunner-specific
# variables, and creates apprunner-{service}.tf for each service.
#
# Prerequisites: Run ./scripts/setup-terraform-base.sh first
#
# Usage: ./scripts/setup-terraform-apprunner.sh [SERVICE_NAME]
#
# Examples:
#   ./scripts/setup-terraform-apprunner.sh web           # Create apprunner-web.tf
#   ./scripts/setup-terraform-apprunner.sh admin         # Create apprunner-admin.tf
#   ./scripts/setup-terraform-apprunner.sh               # Create apprunner-runner.tf (default)
# =============================================================================

set -e

# Parse command line arguments
SERVICE_NAME="${1:-runner}"  # Default: 'runner' for backward compatibility

TERRAFORM_DIR="terraform"
BOOTSTRAP_DIR="bootstrap"
ENVIRONMENTS=("dev" "test" "prod")

echo "üöÄ Setting up App Runner service Terraform configuration..."
echo ""

# =============================================================================
# Validate Service Directory
# =============================================================================

# Check if service directory exists in backend/
if [ ! -d "backend/${SERVICE_NAME}" ]; then
  echo "‚ùå Error: Service directory not found: backend/${SERVICE_NAME}"
  echo ""
  echo "Available services in backend/:"
  ls -d backend/*/ 2>/dev/null | xargs -n1 basename | grep -v "^$" || echo "  None found"
  echo ""
  echo "To create a new service, first create the directory:"
  echo "  mkdir -p backend/${SERVICE_NAME}"
  echo "  cp -r backend/runner/* backend/${SERVICE_NAME}/"
  echo "  # Then customize backend/${SERVICE_NAME}/main.py for your service"
  exit 1
fi

echo "‚úÖ Service directory found: backend/${SERVICE_NAME}"
echo ""

# =============================================================================
# Check Prerequisites
# =============================================================================

# Check if base Terraform files exist
if [ ! -f "$TERRAFORM_DIR/main.tf" ] || [ ! -f "$TERRAFORM_DIR/variables.tf" ]; then
  echo "‚ùå Error: Base Terraform configuration not found"
  echo ""
  echo "Please run setup-terraform-base.sh first:"
  echo "  ./scripts/setup-terraform-base.sh"
  echo ""
  exit 1
fi

# =============================================================================
# Check Bootstrap Configuration
# =============================================================================

if [ ! -f "$BOOTSTRAP_DIR/terraform.tfvars" ]; then
  echo "‚ö†Ô∏è  Warning: Bootstrap terraform.tfvars not found"
  echo "   Using default values for examples"
  echo "   You should run bootstrap first: cp bootstrap/terraform.tfvars.example bootstrap/terraform.tfvars"
  echo ""
  PROJECT_NAME="<YOUR-PROJECT>"
  AWS_REGION="us-east-1"
else
  # Read configuration from bootstrap
  PROJECT_NAME=$(grep '^project_name' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  AWS_REGION=$(grep '^aws_region' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_ORG=$(grep '^github_org' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
  GITHUB_REPO=$(grep '^github_repo' "$BOOTSTRAP_DIR/terraform.tfvars" | cut -d'=' -f2 | cut -d'#' -f1 | tr -d ' "')
fi

# Set defaults if not found
: ${GITHUB_ORG:="<YOUR-ORG>"}
: ${GITHUB_REPO:="<YOUR-REPO>"}

echo "üìã Configuration:"
echo "   Service: $SERVICE_NAME"
echo "   Project: $PROJECT_NAME"
echo "   Region: $AWS_REGION"
echo "   GitHub: $GITHUB_ORG/$GITHUB_REPO"
echo ""

# =============================================================================
# Create apprunner-variables.tf (AppRunner-Specific Variables Only)
# =============================================================================
APPRUNNER_VARS_FILE="$TERRAFORM_DIR/apprunner-variables.tf"

if [ ! -f "$APPRUNNER_VARS_FILE" ]; then
  echo "üìù Creating terraform/apprunner-variables.tf..."
  cat > "$APPRUNNER_VARS_FILE" <<'EOF'
# =============================================================================
# App Runner Service Variables
# =============================================================================
# Generated by scripts/setup-terraform-apprunner.sh
# These variables are specific to App Runner services
# Common variables are in variables.tf
# =============================================================================

variable "apprunner_cpu" {
  description = "Default App Runner CPU units (256, 512, 1024, 2048, 4096)"
  type        = string
  default     = "1024"

  validation {
    condition     = contains(["256", "512", "1024", "2048", "4096"], var.apprunner_cpu)
    error_message = "CPU must be one of: 256, 512, 1024, 2048, 4096"
  }
}

variable "apprunner_memory" {
  description = "Default App Runner memory in MB (512, 1024, 2048, 3072, 4096, 6144, 8192, 10240, 12288)"
  type        = string
  default     = "2048"

  validation {
    condition     = contains(["512", "1024", "2048", "3072", "4096", "6144", "8192", "10240", "12288"], var.apprunner_memory)
    error_message = "Memory must be one of: 512, 1024, 2048, 3072, 4096, 6144, 8192, 10240, 12288"
  }
}

variable "apprunner_port" {
  description = "Default port your application listens on"
  type        = number
  default     = 8080
}

variable "apprunner_min_instances" {
  description = "Default minimum number of App Runner instances"
  type        = number
  default     = 1
}

variable "apprunner_max_instances" {
  description = "Default maximum number of App Runner instances"
  type        = number
  default     = 2
}

variable "apprunner_max_concurrency" {
  description = "Default maximum concurrent requests per instance"
  type        = number
  default     = 100
}

# Health Check Configuration
variable "health_check_path" {
  description = "Default health check endpoint path"
  type        = string
  default     = "/health"
}

variable "health_check_interval" {
  description = "Default health check interval in seconds"
  type        = number
  default     = 10
}

variable "health_check_timeout" {
  description = "Default health check timeout in seconds"
  type        = number
  default     = 5
}

variable "health_check_healthy_threshold" {
  description = "Default number of consecutive successful health checks"
  type        = number
  default     = 1
}

variable "health_check_unhealthy_threshold" {
  description = "Default number of consecutive failed health checks"
  type        = number
  default     = 5
}

# =============================================================================
# Per-Service AppRunner Configuration (Optional)
# =============================================================================
# Use this to configure different settings for each AppRunner service
# If not provided, defaults above will be used

variable "apprunner_service_configs" {
  description = "Per-service AppRunner configuration"
  type = map(object({
    cpu             = optional(string)
    memory          = optional(string)
    port            = optional(number)
    min_instances   = optional(number)
    max_instances   = optional(number)
    max_concurrency = optional(number)
    health_check_path = optional(string)
  }))
  default = {}
}

# Example usage in environments/{env}.tfvars:
#
# apprunner_service_configs = {
#   web = {
#     cpu             = "1024"
#     memory          = "2048"
#     port            = 8080
#     min_instances   = 2
#     max_instances   = 10
#     max_concurrency = 200
#   }
#   admin = {
#     cpu             = "512"
#     memory          = "1024"
#     port            = 8080
#     min_instances   = 1
#     max_instances   = 3
#     max_concurrency = 100
#   }
#   worker = {
#     cpu             = "2048"
#     memory          = "4096"
#     port            = 8080
#     min_instances   = 1
#     max_instances   = 5
#     max_concurrency = 50
#   }
# }
EOF
  echo "‚úÖ Created terraform/apprunner-variables.tf"
else
  echo "‚ÑπÔ∏è  AppRunner variables file already exists (terraform/apprunner-variables.tf)"
fi

# =============================================================================
# Update environment tfvars with AppRunner-specific defaults
# =============================================================================
for ENV in "${ENVIRONMENTS[@]}"; do
  TFVARS_FILE="$TERRAFORM_DIR/environments/${ENV}.tfvars"

  if [ -f "$TFVARS_FILE" ]; then
    # Check if AppRunner variables are already present
    if ! grep -q "^apprunner_cpu" "$TFVARS_FILE" 2>/dev/null; then
      echo "üìù Adding AppRunner variables to $TFVARS_FILE..."

      cat >> "$TFVARS_FILE" <<EOF

# =============================================================================
# App Runner Configuration
# =============================================================================

apprunner_cpu            = "$([ "$ENV" = "prod" ] && echo "2048" || echo "1024")"
apprunner_memory         = "$([ "$ENV" = "prod" ] && echo "4096" || echo "2048")"
apprunner_port           = 8080
apprunner_min_instances  = $([ "$ENV" = "prod" ] && echo "2" || echo "1")
apprunner_max_instances  = $([ "$ENV" = "prod" ] && echo "10" || echo "5")
apprunner_max_concurrency = $([ "$ENV" = "prod" ] && echo "200" || echo "100")

# Health Check
health_check_path                = "/health"
health_check_interval            = 10
health_check_timeout             = 5
health_check_healthy_threshold   = 1
health_check_unhealthy_threshold = 5

# Per-service AppRunner configuration (optional)
# apprunner_service_configs = {
#   web = {
#     cpu             = "1024"
#     memory          = "2048"
#     port            = 8080
#     min_instances   = 2
#     max_instances   = 10
#     max_concurrency = 200
#   }
#   admin = {
#     cpu             = "512"
#     memory          = "1024"
#     port            = 8001
#     min_instances   = 1
#     max_instances   = 3
#     max_concurrency = 100
#   }
# }
EOF
    else
      echo "‚ÑπÔ∏è  AppRunner variables already present in $TFVARS_FILE"
    fi
  fi
done

# =============================================================================
# Create apprunner-{service}.tf
# =============================================================================
APPRUNNER_TF_FILE="$TERRAFORM_DIR/apprunner-${SERVICE_NAME}.tf"

# Check if file already exists
if [ -f "$APPRUNNER_TF_FILE" ]; then
  echo "‚ö†Ô∏è  Warning: ${APPRUNNER_TF_FILE} already exists"
  read -p "Overwrite? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Skipping apprunner-${SERVICE_NAME}.tf generation"
    echo "‚úÖ Setup completed (existing files preserved)"
    exit 0
  fi
fi

echo "üìù Creating ${APPRUNNER_TF_FILE}..."
cat > "$APPRUNNER_TF_FILE" <<'TEMPLATE_EOF'
# =============================================================================
# App Runner Service Configuration: SERVICE_NAME_PLACEHOLDER
# =============================================================================
# Generated by scripts/setup-terraform-apprunner.sh
# This file defines the App Runner service for the SERVICE_NAME_PLACEHOLDER service
# =============================================================================

# Service-specific configuration
# Edit these values to customize this App Runner service
locals {
  SERVICE_NAME_PLACEHOLDER_config = {
    cpu             = "1024"
    memory          = "2048"
    port            = 8080
    min_instances   = 1
    max_instances   = 5
    max_concurrency = 100
    health_check_path = "/health"
    # Add service-specific environment variables here
    environment_variables = {
      # KEY = "value"
    }
  }
}

# Get App Runner IAM roles from bootstrap
data "aws_iam_role" "apprunner_access_SERVICE_NAME_PLACEHOLDER" {
  name = "${var.project_name}-apprunner-access"
}

data "aws_iam_role" "apprunner_instance_SERVICE_NAME_PLACEHOLDER" {
  name = "${var.project_name}-apprunner-instance"
}

# Observability Configuration (OpenTelemetry via X-Ray)
# Note: AWS X-Ray supports OTLP traces from OpenTelemetry
resource "aws_apprunner_observability_configuration" "SERVICE_NAME_PLACEHOLDER" {
  observability_configuration_name = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER-obs"

  trace_configuration {
    vendor = "AWSXRAY"
  }

  tags = {
    Name    = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER-obs"
    Service = "SERVICE_NAME_PLACEHOLDER"
  }
}

# App Runner Service
resource "aws_apprunner_service" "SERVICE_NAME_PLACEHOLDER" {
  service_name = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER"

  source_configuration {
    image_repository {
      image_identifier      = "${data.aws_ecr_repository.app.repository_url}:SERVICE_NAME_PLACEHOLDER-${var.environment}-latest"
      image_repository_type = "ECR"

      image_configuration {
        # Port - uses local config
        port = local.SERVICE_NAME_PLACEHOLDER_config.port

        runtime_environment_variables = merge(
          {
            ENVIRONMENT  = var.environment
            PROJECT_NAME = var.project_name
            SERVICE_NAME = "SERVICE_NAME_PLACEHOLDER"
            LOG_LEVEL    = var.environment == "prod" ? "INFO" : "DEBUG"
          },
          local.SERVICE_NAME_PLACEHOLDER_config.environment_variables
        )
      }
    }

    authentication_configuration {
      access_role_arn = data.aws_iam_role.apprunner_access_SERVICE_NAME_PLACEHOLDER.arn
    }

    auto_deployments_enabled = false
  }

  instance_configuration {
    # CPU and Memory - uses local config
    cpu    = local.SERVICE_NAME_PLACEHOLDER_config.cpu
    memory = local.SERVICE_NAME_PLACEHOLDER_config.memory

    instance_role_arn = data.aws_iam_role.apprunner_instance_SERVICE_NAME_PLACEHOLDER.arn
  }

  health_check_configuration {
    protocol            = "HTTP"
    path                = local.SERVICE_NAME_PLACEHOLDER_config.health_check_path
    interval            = var.health_check_interval
    timeout             = var.health_check_timeout
    healthy_threshold   = var.health_check_healthy_threshold
    unhealthy_threshold = var.health_check_unhealthy_threshold
  }

  # Observability configuration (distributed tracing)
  observability_configuration {
    observability_enabled           = true
    observability_configuration_arn = aws_apprunner_observability_configuration.SERVICE_NAME_PLACEHOLDER.arn
  }

  auto_scaling_configuration_arn = aws_apprunner_auto_scaling_configuration_version.SERVICE_NAME_PLACEHOLDER.arn

  tags = {
    Name        = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER"
    Service     = "SERVICE_NAME_PLACEHOLDER"
    Description = "SERVICE_NAME_PLACEHOLDER App Runner service"
  }
}

# Auto Scaling Configuration
resource "aws_apprunner_auto_scaling_configuration_version" "SERVICE_NAME_PLACEHOLDER" {
  auto_scaling_configuration_name = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER-as"

  # Uses local config
  min_size        = local.SERVICE_NAME_PLACEHOLDER_config.min_instances
  max_size        = local.SERVICE_NAME_PLACEHOLDER_config.max_instances
  max_concurrency = local.SERVICE_NAME_PLACEHOLDER_config.max_concurrency

  tags = {
    Name    = "${var.project_name}-${var.environment}-SERVICE_NAME_PLACEHOLDER-as"
    Service = "SERVICE_NAME_PLACEHOLDER"
  }
}

# =============================================================================
# Outputs for SERVICE_NAME_PLACEHOLDER Service
# =============================================================================

output "apprunner_SERVICE_NAME_PLACEHOLDER_service_id" {
  description = "ID of the SERVICE_NAME_PLACEHOLDER App Runner service"
  value       = aws_apprunner_service.SERVICE_NAME_PLACEHOLDER.service_id
}

output "apprunner_SERVICE_NAME_PLACEHOLDER_service_arn" {
  description = "ARN of the SERVICE_NAME_PLACEHOLDER App Runner service"
  value       = aws_apprunner_service.SERVICE_NAME_PLACEHOLDER.arn
}

output "apprunner_SERVICE_NAME_PLACEHOLDER_url" {
  description = "App Runner service URL for SERVICE_NAME_PLACEHOLDER"
  value       = "https://${aws_apprunner_service.SERVICE_NAME_PLACEHOLDER.service_url}"
}

output "apprunner_SERVICE_NAME_PLACEHOLDER_status" {
  description = "Status of the SERVICE_NAME_PLACEHOLDER App Runner service"
  value       = aws_apprunner_service.SERVICE_NAME_PLACEHOLDER.status
}
TEMPLATE_EOF

# Replace placeholders with actual service name
sed -i "s/SERVICE_NAME_PLACEHOLDER/${SERVICE_NAME}/g" "$APPRUNNER_TF_FILE"

# =============================================================================
# API Gateway Integration (Optional)
# =============================================================================
API_GATEWAY_FILE="$TERRAFORM_DIR/api-gateway.tf"

if [ -f "$API_GATEWAY_FILE" ]; then
  echo ""
  echo "üìù API Gateway configuration found"
  echo ""
  read -p "Do you want to add '${SERVICE_NAME}' to API Gateway? (y/N): " -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
    # Check if AppRunner integrations section exists
    if ! grep -q "# AppRunner Service Integrations" "$API_GATEWAY_FILE"; then
      echo "üìù Adding AppRunner integrations section to api-gateway.tf..."
      cat >> "$API_GATEWAY_FILE" <<'EOF'

# =============================================================================
# AppRunner Service Integrations
# =============================================================================

EOF
    fi

    # Check if this service integration already exists
    if grep -q "module \"api_gateway_apprunner_${SERVICE_NAME}\"" "$API_GATEWAY_FILE"; then
      echo "‚ÑπÔ∏è  Integration for '${SERVICE_NAME}' already exists in api-gateway.tf"
    else
      echo "üìù Appending integration for '${SERVICE_NAME}' to api-gateway.tf..."

      cat >> "$API_GATEWAY_FILE" <<EOF

# Integration for '${SERVICE_NAME}' AppRunner service
module "api_gateway_apprunner_${SERVICE_NAME}" {
  source = "./modules/api-gateway-apprunner-integration"
  count  = local.api_gateway_enabled ? 1 : 0

  service_name = "${SERVICE_NAME}"
  path_prefix  = "${SERVICE_NAME}"  # /${SERVICE_NAME}, /${SERVICE_NAME}/*

  api_id                = module.api_gateway_shared[0].api_id
  api_root_resource_id  = module.api_gateway_shared[0].root_resource_id
  api_execution_arn     = module.api_gateway_shared[0].execution_arn

  apprunner_service_url = aws_apprunner_service.${SERVICE_NAME}.service_url

  api_key_required      = var.enable_api_key
}
EOF

      echo "‚úÖ Added integration module for '${SERVICE_NAME}'"

      # =============================================================================
      # Update api_gateway_shared module to include integration_ids
      # =============================================================================
      echo "üìù Updating api_gateway_shared module with integration dependencies..."

      # Check if integration_ids already exists in the shared module
      if grep -q "integration_ids.*=" "$API_GATEWAY_FILE"; then
        # integration_ids line already exists, we need to add this service to the list
        # Create a temporary file with the updated integration_ids
        awk -v service="${SERVICE_NAME}" '
          /integration_ids.*=.*\[/ {
            # Found the start of integration_ids list
            in_integration_list = 1
            print $0
            next
          }
          in_integration_list && /\]/ {
            # End of integration_ids list, add new service before closing bracket
            print "    module.api_gateway_apprunner_" service "[0].integration_id,"
            in_integration_list = 0
            print $0
            next
          }
          { print $0 }
        ' "$API_GATEWAY_FILE" > "${API_GATEWAY_FILE}.tmp"

        mv "${API_GATEWAY_FILE}.tmp" "$API_GATEWAY_FILE"
        echo "‚úÖ Added '${SERVICE_NAME}' to existing integration_ids list"
      else
        # integration_ids doesn't exist, add it to the shared module
        awk -v service="${SERVICE_NAME}" '
          /^module "api_gateway_shared"/ {
            in_shared_module = 1
          }
          in_shared_module && /count.*=.*local.api_gateway_enabled/ {
            print $0
            print ""
            print "  # Integration IDs for deployment dependencies"
            print "  # This ensures the deployment waits for all integrations to be created"
            print "  integration_ids = local.api_gateway_enabled ? ["
            print "    module.api_gateway_apprunner_" service "[0].integration_id,"
            print "  ] : []"
            in_shared_module = 0
            next
          }
          { print $0 }
        ' "$API_GATEWAY_FILE" > "${API_GATEWAY_FILE}.tmp"

        mv "${API_GATEWAY_FILE}.tmp" "$API_GATEWAY_FILE"
        echo "‚úÖ Added integration_ids to api_gateway_shared module"
      fi
    fi
  else
    echo "‚ÑπÔ∏è  Skipping API Gateway integration"
    echo "   Service will be accessible directly via AppRunner URL"
  fi
else
  echo "‚ÑπÔ∏è  API Gateway not configured"
  echo "   Service will be accessible directly via AppRunner URL"
fi

echo ""
echo "‚úÖ App Runner service '${SERVICE_NAME}' Terraform configuration created successfully!"
echo ""
echo "üìÇ Created/Updated files:"
echo "   terraform/apprunner-variables.tf"
echo "   terraform/apprunner-${SERVICE_NAME}.tf ‚ú®"
if [ -f "$API_GATEWAY_FILE" ]; then
  echo "   terraform/api-gateway.tf (optionally updated)"
fi
for ENV in "${ENVIRONMENTS[@]}"; do
  if [ -f "$TERRAFORM_DIR/environments/${ENV}.tfvars" ]; then
    echo "   terraform/environments/${ENV}.tfvars (updated)"
  fi
done
echo ""
echo "üöÄ Next Steps for '${SERVICE_NAME}' Service:"
echo ""
echo "1. Build and push Docker image:"
echo "   ./scripts/docker-push.sh dev ${SERVICE_NAME} Dockerfile.apprunner"
echo ""
echo "2. Deploy infrastructure:"
echo "   make app-init-dev app-apply-dev"
echo ""
echo "3. Test the deployed service:"
echo "   APPRUNNER_URL=\$(cd terraform && terraform output -raw apprunner_${SERVICE_NAME}_url)"
echo "   curl \$APPRUNNER_URL/health"
echo ""
echo "üí° To configure service-specific settings (CPU, memory, scaling, etc.):"
echo "   Edit terraform/environments/dev.tfvars and add to apprunner_service_configs"
echo ""
